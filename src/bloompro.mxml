<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   initialize="windowedApplication_initializeHandler(event)"
					   creationComplete="windowedapplication_creationCompleteHandler(event)"
					   keyDown="windowedapplication_keyDownHandler(event)"
					   usePreloader="false"
					   backgroundAlpha="0"
					   backgroundColor="#696969"
					   showStatusBar="true"
					   frameRate="60"
					   >
	
	<fx:Script>
		<![CDATA[
			import brush.Brush;
			import brush.Brush1;
			import brush.Brush2;
			
			import mx.events.FlexEvent;
			import mx.graphics.SolidColor;
			import mx.utils.StringUtil;
			
			import spark.filters.DropShadowFilter;
			import spark.skins.spark.ImageSkin;
			
			// ........................................................................................
			
			private var frameCount:uint = 0;
			private var curMillisecondCount:uint = 0;
			private var prevMillisecondCount:uint = getTimer();
			private var fps:Number = 0.0;
			private var delta:uint;
			
			[Bindable] private var canvasBackgroundColor:uint = 0xffffff;
			
			private var outsideSourceFlag:Boolean = false;
			private var sourceLocal:Point = new Point();
			private var stagePoint:Point = new Point();
			private var sampleColor:uint = 0;
			
			private var flushTimer:Timer = new Timer(1000);
			private var statusTimer:Timer = new Timer(2000, 1);
			
			private var keyBinds:Array = new Array();
			
			private var brushes:Array = new Array();
			
			private var lastCommandInput:String = "";
			
			// ........................................................................................
			
			protected function windowedApplication_initializeHandler(event:FlexEvent):void
			{
				this.nativeWindow.maximize();
				
				var scope:Object = this;
				
				ConsoleCommand.addCommand("exit", function ():void { scope.exit(); }, false);
				ConsoleCommand.addCommand("open", openImage);
				ConsoleCommand.addCommand("frame-rate", function (frameRate:Number):void { 
					if(frameRate == 0)
					{
						status = "! frame-rate cannot be 0";
						statusTimer.start();
						return;
					}
					scope.stage.frameRate = frameRate; 
				});			
				ConsoleCommand.addCommand("source-alpha", function (alpha:Number):void { scope.sourceBitmap.alpha = alpha; });
				ConsoleCommand.addCommand("bind-key", bindKey);
				ConsoleCommand.addCommand("save-key-binds", saveKeyBinds);
				ConsoleCommand.addCommand("load-key-binds", loadKeyBinds);
				ConsoleCommand.addCommand("clear", function():void {
					
					scope.canvasContainer.graphics.beginFill(0xffffff, 1);
					scope.canvasContainer.graphics.drawRect(0, 0, scope.canvasContainer.width, scope.canvasContainer.height);
					scope.canvasContainer.graphics.endFill();
					scope.flushBitmap.source.bitmapData.draw(canvasContainer);
					scope.canvasContainer.graphics.clear();
				});
				
				ConsoleCommand.addCommand("load-brush", function (brushNum:Number):void {
					
					if(brushNum == 0)
					{
						status = "! specify a brush #";
						statusTimer.start();
						return;
					}
					
					var brush:Brush = null;
					
					switch(brushNum)
					{
						case 1: brush = new Brush1(); break;
						case 2: brush = new Brush2(); break;
					}
					
					brushes[brushNum] = brush;
				});
				ConsoleCommand.addCommand("line-width-brush", function (brushNum:Number, value:Number):void { brushes[brushNum].lineWidth = value; });
				ConsoleCommand.addCommand("alpha-brush", function (brushNum:Number, value:Number):void { brushes[brushNum].alpha = value; });
				ConsoleCommand.addCommand("radius-brush", function (brushNum:Number, value:Number):void { brushes[brushNum].radius = value; });
				ConsoleCommand.addCommand("iterations-brush", function (brushNum:Number, value:Number):void { brushes[brushNum].iterations = value; });
				ConsoleCommand.addCommand("automate-brush", function (offset:Number):void {
					
					if(offset == 0)
					{
						status = "! specify a non-zero offset";
						statusTimer.start();
						return;
					}
					
					for each(var b:Brush in brushes)
						b.mouseDown(scope.sourceBitmap.x, scope.sourceBitmap.y);
					
					var t:Timer = new Timer(0.25, int(scope.sourceBitmap.height / offset));
					var i:int = 0;
					var j:int = 0;
					
					t.addEventListener(TimerEvent.TIMER, function (event:TimerEvent):void {
						
						for(; i < scope.sourceBitmap.width; i += offset)
						{
							for each(var br:Brush in scope.brushes)
							{
									br.draw(scope.canvasContainer.graphics,
											scope.sourceBitmap.source.bitmapData.getPixel(i, j),
											scope.sourceBitmap.x + i,
											scope.sourceBitmap.y + j);
							}
						}
						
						i = 0;
						j += offset;
						
						scope.flushToBitmap();
					});
						
					t.start();
				});
			}
			
			protected function windowedapplication_creationCompleteHandler(event:FlexEvent):void
			{
				var dropShadow:DropShadowFilter = new spark.filters.DropShadowFilter();
				dropShadow.color = 0x000000;
				dropShadow.alpha = 0.4;
				dropShadow.blurX = 5;
				dropShadow.blurY = 5;
				dropShadow.distance = 5;
				input.filters = [dropShadow];
				renderGroup.filters = [dropShadow];
				
				input.setFocus();
					
				this.addEventListener(Event.ENTER_FRAME, windowedApplication_enterFrameHandler);
				statusTimer.addEventListener(TimerEvent.TIMER_COMPLETE, function (event:TimerEvent):void {
					status = "";
				});
			}
			
			private function windowedApplication_enterFrameHandler(event:Event):void
			{
				++frameCount;
				
				curMillisecondCount = getTimer();
				delta = curMillisecondCount - prevMillisecondCount;
				if (delta > 1000)
				{
					fps = frameCount / delta * 1000;
					fpsLabel.text = fps.toFixed(1) + " fps";
					prevMillisecondCount = curMillisecondCount;
					frameCount = 0;		
				}
			}
			
			protected function windowedapplication_keyDownHandler(event:KeyboardEvent):void
			{
				if(event.commandKey)
				{
					switch(event.keyCode)
					{
						case Keyboard.L:
							
							input.setFocus();
							
							break;
					}
				}
				else
				{
					if(keyBinds[event.charCode])
						ConsoleCommand.process(keyBinds[event.charCode]);
				}
			}
			
			// ........................................................................................
			
			private function loadKeyBinds(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName);
				if(file.exists)
				{
					var fs:FileStream = new FileStream();
					
					fs.open(file, FileMode.READ);
					
					var fullBindListing:String = fs.readUTFBytes(fs.bytesAvailable);
					var tokens:Array = fullBindListing.split("\n");
					
					// bind-key 
					for each(var input:String in tokens)
					{
						// assumed input; will blow up otherwise
						var key:String = input.substr("bind-key ".length, 1);
						keyBinds[key.charCodeAt()] = input.substring("bind-key x \"".length, input.length-1); // remove double quotes
					}
					
					fs.close();
				}
			}
			
			private function saveKeyBinds(fileName:String):void
			{	
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName);
				var fs:FileStream = new FileStream();
				
				fs.open(file, FileMode.WRITE);
				
				for (var key:String in keyBinds)
					fs.writeUTFBytes(StringUtil.substitute("bind-key {0} \"{1}\"\n", String.fromCharCode(key), keyBinds[key]));
				
				fs.close();
			}
			
			private function bindKey(key:String, input:String):void
			{
				keyBinds[key.charCodeAt()] = input;
			}
			
			protected function inputKeyDown(event:KeyboardEvent):void
			{	
				switch(event.keyCode)
				{
					case Keyboard.ESCAPE:
						
						renderGroup.setFocus();
						
						break;
					
					case Keyboard.TAB:
						
						if(input.text.length == 0)
							renderGroup.setFocus();
						else
						{
							var partial:String = ConsoleCommand.autoComplete(input.text);
							if(partial != null)
								input.appendText(partial);
						}
						
						break;
					
					case Keyboard.ENTER:
						lastCommandInput = input.text;
						try
						{
							ConsoleCommand.process(input.text);
						}
						catch(e:Error)
						{
							status = "! incorrect params";
							statusTimer.start();	
						}
						input.text = "";
						
						break;
					
					case Keyboard.UP:
						input.appendText(lastCommandInput);

						break;
				}
				
				event.stopImmediatePropagation();
			}
			
			// ........................................................................................
			
			private function openImage(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var appDir:File = File.applicationDirectory;
				var dirListing:Array = appDir.getDirectoryListing();
				
				for each(var file:File in dirListing)
				{	
					if(file.name == fileName)
					{	
						var loader:Loader = new Loader();
						loader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadCompleteHandler);
						loader.load(new URLRequest(file.url)); 
					}
				}
			}
			
			private function imageLoadCompleteHandler(event:Event):void
			{	
				var bitmap:Bitmap = event.currentTarget.content as Bitmap;
				sourceBitmap.source = bitmap;
				
				flushBitmap.source = new Bitmap(new BitmapData(renderGroup.width, renderGroup.height, false, 0xffffff));
				
				var centerX:Number = renderGroup.width / 2;
				var centerY:Number = renderGroup.height / 2;
				
				sourceBitmap.x = centerX - (sourceBitmap.source.bitmapData.width  / 2);
				sourceBitmap.y = centerY - (sourceBitmap.source.bitmapData.height / 2);
				
				colorSampleRect.fill = new SolidColor();
				
				flushTimer.addEventListener(TimerEvent.TIMER, tick);
				flushTimer.start();
			}
			
			// ........................................................................................
			
			private function tick(event:TimerEvent):void
			{
				flushToBitmap();
			}
			
			private function flushToBitmap():void
			{
				flushBitmap.source.bitmapData.draw(canvasContainer);	
				canvasContainer.graphics.clear();
			}
			
			// ........................................................................................
			
			private function draw(event:MouseEvent):void
			{
				for each(var br:Brush in brushes)
				{
					br.draw(canvasContainer.graphics,
							sampleColor,
							event.stageX - renderGroup.x,
							event.stageY - renderGroup.y);
				}
			}
			
			// ........................................................................................
			
			protected function renderGroup_mouseDownHandler(event:MouseEvent):void
			{
				renderGroup.setFocus();
					
				if(sourceBitmap.source)
				{
					flushTimer.start();
					
					for each(var b:Brush in brushes)
						b.mouseDown(event.stageX - renderGroup.x, event.stageY - renderGroup.y);
					
					draw(event);
				}
			}
			
			protected function renderGroup_mouseUpHandler(event:MouseEvent):void
			{
				if(sourceBitmap.source)
				{
					flushTimer.stop();
					flushToBitmap();
				}
			}
			
			protected function renderGroup_mouseMoveHandler(event:MouseEvent):void
			{
				if(sourceBitmap.source)
				{
					if(outsideSourceFlag)
					{
						stagePoint.x = event.stageX;
						stagePoint.y = event.stageY;
						sourceLocal = sourceBitmap.globalToLocal(stagePoint);
						
						// clamp
						if(sourceLocal.x < 0)
							sourceLocal.x = 0;
						else if(sourceLocal.x > sourceBitmap.source.bitmapData.width)
							sourceLocal.x = sourceBitmap.source.bitmapData.width - 1;
						if(sourceLocal.y < 0)
							sourceLocal.y = 0;
						else if(sourceLocal.y > sourceBitmap.source.bitmapData.height)
							sourceLocal.y = sourceBitmap.source.bitmapData.height - 1;
						
						sampleColor = sourceBitmap.source.bitmapData.getPixel(sourceLocal.x, sourceLocal.y);
						SolidColor(colorSampleRect.fill).color = sampleColor;
					}
					
					if(event.buttonDown)
						draw(event);
				}
			}
			
			protected function renderGroup_mouseOverHandler(event:MouseEvent):void
			{
				colorSampleRect.visible = true;
			}
			
			protected function renderGroup_mouseOutHandler(event:MouseEvent):void
			{
				colorSampleRect.visible = false;
			}
			
			// ........................................................................................
			
			protected function sourceBitmap_mouseOverHandler(event:MouseEvent):void
			{
				outsideSourceFlag = false;
				mousePosLabel.visible = true;
			}
			
			protected function sourceBitmap_mouseOutHandler(event:MouseEvent):void
			{
				outsideSourceFlag = true;
				mousePosLabel.visible = false;
			}
			
			protected function sourceBitmap_mouseMoveHandler(event:MouseEvent):void
			{
				mousePosLabel.text = StringUtil.substitute("{x:{0}, y:{1}}", event.localX, event.localY);
				
				if(sourceBitmap.source)
				{
					sampleColor = sourceBitmap.source.bitmapData.getPixel(event.localX, event.localY);
					SolidColor(colorSampleRect.fill).color = sampleColor;
				
					if(event.buttonDown)
						draw(event);
				}
				
				event.stopImmediatePropagation();
			}
			
		]]>
	</fx:Script>
	
	<s:VGroup id="vgroup" 
			  width="100%" height="100%"
			  paddingBottom="40" paddingLeft="40" paddingRight="40" paddingTop="40"
			  >
		
		<s:TextInput id="input" 
					 width="100%" 
					 focusEnabled="false"
					 fontFamily="Monaco"
					 fontSize="11"
					 keyDown="inputKeyDown(event)"
					 />
	
		<s:SkinnableContainer
				id="renderGroup"
				width="100%" height="100%"
				backgroundColor="{canvasBackgroundColor}"
				mouseMove="renderGroup_mouseMoveHandler(event)"
				mouseOut="renderGroup_mouseOutHandler(event)"
				mouseOver="renderGroup_mouseOverHandler(event)"
				mouseDown="renderGroup_mouseDownHandler(event)"
				mouseUp="renderGroup_mouseUpHandler(event)"
				>
			
			<s:BitmapImage id="flushBitmap" width="100%" height="100%"/>
			
			<s:Image id="sourceBitmap" 
					 mouseMove="sourceBitmap_mouseMoveHandler(event)"
					 mouseOut="sourceBitmap_mouseOutHandler(event)"
					 mouseOver="sourceBitmap_mouseOverHandler(event)"
					 />
			
			<s:SpriteVisualElement id="canvasContainer"
								   width="100%" height="100%"/>
		
		</s:SkinnableContainer>
		
		<s:HGroup width="100%" verticalAlign="baseline">
			<s:HGroup width="100%" horizontalAlign="left">
				<s:Rect id="colorSampleRect" width="10" height="10"/>
			</s:HGroup>	
			
			<s:HGroup width="100%" gap="20" horizontalAlign="right">	
				<s:Label id="mousePosLabel"
						 paddingTop="10" 
						 color="0xacacac"
						 fontFamily="Monaco" fontSize="9"
						 width="87"
						 />
				
				<s:Label id="fpsLabel" 
					paddingTop="10" 
					color="0xacacac"
					fontFamily="Monaco" fontSize="9"
					/>			
			</s:HGroup>
		</s:HGroup>

	</s:VGroup>
	
</s:WindowedApplication>
