<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   initialize="windowedApplication_initializeHandler(event)"
					   creationComplete="windowedapplication_creationCompleteHandler(event)"
					   keyDown="windowedapplication_keyDownHandler(event)"
					   usePreloader="false"
					   backgroundAlpha="0"
					   backgroundColor="#696969"
					   showStatusBar="true"
					   frameRate="60"
					   >
	
	<fx:Script>
		<![CDATA[
			import brush.Brush;
			import brush.Brush1;
			import brush.Brush10;
			import brush.Brush11;
			import brush.Brush12;
			import brush.Brush13;
			import brush.Brush14;
			import brush.Brush15;
			import brush.Brush16;
			import brush.Brush17;
			import brush.Brush18;
			import brush.Brush19;
			import brush.Brush2;
			import brush.Brush20;
			import brush.Brush21;
			import brush.Brush22;
			import brush.Brush23;
			import brush.Brush24;
			import brush.Brush25;
			import brush.Brush3;
			import brush.Brush4;
			import brush.Brush5;
			import brush.Brush6;
			import brush.Brush7;
			import brush.Brush8;
			import brush.Brush9;
			
			import flash.utils.getDefinitionByName;
			
			import mx.collections.ArrayList;
			import mx.controls.Alert;
			import mx.events.FlexEvent;
			import mx.events.IndexChangedEvent;
			import mx.graphics.SolidColor;
			import mx.graphics.codec.PNGEncoder;
			import mx.utils.StringUtil;
			
			import spark.events.IndexChangeEvent;
			import spark.filters.DropShadowFilter;
			import spark.skins.spark.ImageSkin;
			
			// ........................................................................................
			
			// include refs for getDefinitionByName
			private var b1:Brush1;
			private var b2:Brush2;
			private var b3:Brush3;
			private var b4:Brush4;
			private var b5:Brush5;
			private var b6:Brush6;
			private var b7:Brush7;
			private var b8:Brush8;
			private var b9:Brush9;
			private var b10:Brush10;
			private var b11:Brush11;
			private var b12:Brush12;
			private var b13:Brush13;
			private var b14:Brush14;
			private var b15:Brush15;
			private var b16:Brush16;
			private var b17:Brush17;
			private var b18:Brush18;
			private var b19:Brush19;
			private var b20:Brush20;
			private var b21:Brush21;
			private var b22:Brush22;
			private var b23:Brush23;
			private var b24:Brush24;
			private var b25:Brush25;
			
			private var frameCount:uint = 0;
			private var curMillisecondCount:uint = 0;
			private var prevMillisecondCount:uint = getTimer();
			private var fps:Number = 0.0;
			private var delta:uint;
			
			[Bindable] private var canvasBackgroundColor:uint = 0xffffff;
			
			private var outsideSourceFlag:Boolean = false;
			private var sourceLocal:Point = new Point();
			private var stagePoint:Point = new Point();
			private var sampleColor:uint = 0;
			
			private var flushTimer:Timer = new Timer(1000);
			private var statusTimer:Timer = new Timer(2000, 1);
			
			private var keyBinds:Array = new Array();
			
			private var brushes:Array = new Array();
			
			private var lastCommandInput:String = "";
			
			private var opsStream:FileStream = null;
			private var opsFile:File = null;
			
			private var frameWindowRect:Rect = new Rect();
			
			[Bindable] private var colorList:ArrayList = new ArrayList();
			
			// ........................................................................................
			
			protected function windowedApplication_initializeHandler(event:FlexEvent):void
			{
				this.nativeWindow.maximize();
				
				ConsoleCommand.addCommand("exit", _exit, false);
				ConsoleCommand.addCommand("load-drawing", loadDrawingOverwrite);
				ConsoleCommand.addCommand("save-drawing", saveDrawing);
				ConsoleCommand.addCommand("open", openImage);
				ConsoleCommand.addCommand("frame-rate", _frameRate);			
				ConsoleCommand.addCommand("source-alpha", sourceAlpha);
				ConsoleCommand.addCommand("bind-key", bindKey);
				ConsoleCommand.addCommand("save-key-binds", saveKeyBinds);
				ConsoleCommand.addCommand("load-key-binds", loadKeyBinds);
				ConsoleCommand.addCommand("clear", clear);
				ConsoleCommand.addCommand("load-brush", loadBrush);
				ConsoleCommand.addCommand("line-width-brush", lineWidthBrush);
				ConsoleCommand.addCommand("alpha-brush", alphaBrush);
				ConsoleCommand.addCommand("radius-brush", radiusBrush);
				ConsoleCommand.addCommand("iterations-brush", iterationsBrush);
				ConsoleCommand.addCommand("automate-brush", automateBrush);
				ConsoleCommand.addCommand("save-brush-settings", saveBrushSettings);
				ConsoleCommand.addCommand("load-brush-settings", loadBrushSettings);
				ConsoleCommand.addCommand("export", export);
				ConsoleCommand.addCommand("frame-window", _frameWindow);
				ConsoleCommand.addCommand("clear-all-brushes", clearAllBrushes, false);
				ConsoleCommand.addCommand("clear-brush", clearBrush);
				ConsoleCommand.addCommand("clear-palette", function():void { colorList = new ArrayList(); }, false);
				ConsoleCommand.addCommand("randomize-offset", function (brushNum:Number, value:Boolean):void {
					
					brushes[brushNum].randomizeOffset = value;
				});
				ConsoleCommand.addCommand("plus-minus-offset-range", function (brushNum:Number, value:Number):void {
					brushes[brushNum].plusMinusOffsetRange = value;
				});
			}
			
			protected function windowedapplication_creationCompleteHandler(event:FlexEvent):void
			{
				var dropShadow:DropShadowFilter = new spark.filters.DropShadowFilter();
				dropShadow.color = 0x000000;
				dropShadow.alpha = 0.4;
				dropShadow.blurX = 5;
				dropShadow.blurY = 5;
				dropShadow.distance = 5;
				input.filters = [dropShadow];
				renderGroup.filters = [dropShadow];
				list.filters = [dropShadow];
				
				input.setFocus();
					
				this.addEventListener(Event.ENTER_FRAME, windowedApplication_enterFrameHandler);
				statusTimer.addEventListener(TimerEvent.TIMER_COMPLETE, function (event:TimerEvent):void {
					status = "";
				});
			}
			
			private function windowedApplication_enterFrameHandler(event:Event):void
			{
				++frameCount;
				
				curMillisecondCount = getTimer();
				delta = curMillisecondCount - prevMillisecondCount;
				if (delta > 1000)
				{
					fps = frameCount / delta * 1000;
					fpsLabel.text = fps.toFixed(1) + " fps";
					prevMillisecondCount = curMillisecondCount;
					frameCount = 0;		
				}
			}
			
			private function _exit():void
			{ 
				if(opsStream != null)
					opsStream.close();
				
				exit(); 
			}
			
			private function _frameRate(frameRate:Number):void 
			{ 
				if(frameRate == 0)
				{
					status = "! frame-rate cannot be 0";
					statusTimer.start();
					return;
				}
				stage.frameRate = frameRate; 
			}
			
			protected function windowedapplication_keyDownHandler(event:KeyboardEvent):void
			{
				if(event.commandKey)
				{
					switch(event.keyCode)
					{
						case Keyboard.L:
							
							input.setFocus();
							
							break;
						
						case Keyboard.EQUAL:
							
							frameWindowRect.x -= 10;
							frameWindowRect.y -= 10;
							frameWindowRect.width += 20;
							frameWindowRect.height += 20;
							
							frameWindow.graphics.clear();
							frameWindow.graphics.lineStyle(1, 0x000000, 1.0, false, LineScaleMode.NONE);
							frameWindow.graphics.drawRect(frameWindowRect.x, frameWindowRect.y, frameWindowRect.width, frameWindowRect.height);
					
							break;
						
						case Keyboard.MINUS:
							
							frameWindowRect.x += 10;
							frameWindowRect.y += 10;
							frameWindowRect.width -= 20;
							frameWindowRect.height -= 20;
							
							frameWindow.graphics.clear();
							frameWindow.graphics.lineStyle(1, 0x000000, 1.0, false, LineScaleMode.NONE);
							frameWindow.graphics.drawRect(frameWindowRect.x, frameWindowRect.y, frameWindowRect.width, frameWindowRect.height);
							
							break;
					}
				}
				else
				{
					if(keyBinds[event.charCode])
						ConsoleCommand.process(keyBinds[event.charCode]);
				}
			}
			
			// ........................................................................................
			
			private function loadKeyBinds(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName);
				if(file.exists)
				{
					var fs:FileStream = new FileStream();
					
					fs.open(file, FileMode.READ);
					
					var fullBindListing:String = fs.readUTFBytes(fs.bytesAvailable);
					var tokens:Array = fullBindListing.split("\n");
					
					// bind-key 
					for each(var input:String in tokens)
					{
						// assumed input; will blow up otherwise
						var key:String = input.substr("bind-key ".length, 1);
						keyBinds[key.charCodeAt()] = input.substring("bind-key x \"".length, input.length-1); // remove double quotes
					}
					
					fs.close();
				}
			}
			
			private function saveKeyBinds(fileName:String):void
			{	
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName);
				var fs:FileStream = new FileStream();
				
				fs.open(file, FileMode.WRITE);
				
				for (var key:String in keyBinds)
					fs.writeUTFBytes(StringUtil.substitute("bind-key {0} \"{1}\"\n", String.fromCharCode(key), keyBinds[key]));
				
				fs.close();
			}
			
			private function bindKey(key:String, input:String):void
			{
				keyBinds[key.charCodeAt()] = input;
			}
			
			protected function inputKeyDown(event:KeyboardEvent):void
			{	
				switch(event.keyCode)
				{
					case Keyboard.ESCAPE:
						
						renderGroup.setFocus();
						
						break;
					
					case Keyboard.TAB:
						
						if(input.text.length == 0)
							renderGroup.setFocus();
						else
						{
							var partial:String = ConsoleCommand.autoComplete(input.text);
							if(partial != null)
								input.appendText(partial);
						}
						
						break;
					
					case Keyboard.ENTER:
						lastCommandInput = input.text;
						try
						{
							ConsoleCommand.process(input.text);
						}
						catch(e:Error)
						{
							status = "! incorrect params";
							statusTimer.start();	
						}
						input.text = "";
						
						break;
					
					case Keyboard.UP:
						input.appendText(lastCommandInput);

						break;
				}
				
				event.stopImmediatePropagation();
			}
			
			// ........................................................................................
			
			private function openImage(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var dirListing:Array = File.applicationDirectory.getDirectoryListing();
				
				for each(var file:File in dirListing)
				{	
					if(file.name == fileName)
					{	
						var loader:Loader = new Loader();
						loader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadCompleteHandler);
						loader.load(new URLRequest(file.url)); 
					}
				}
			}
			
			private function imageLoadCompleteHandler(event:Event):void
			{	
				var bitmap:Bitmap = event.currentTarget.content as Bitmap;
				sourceBitmap.source = bitmap;
				
				if(flushBitmap.source == null)
					flushBitmap.source = new Bitmap(new BitmapData(renderGroup.width, renderGroup.height, false, 0xffffff));
				
				var centerX:Number = renderGroup.width / 2;
				var centerY:Number = renderGroup.height / 2;
				
				sourceBitmap.x = centerX - (sourceBitmap.source.bitmapData.width  / 2);
				sourceBitmap.y = centerY - (sourceBitmap.source.bitmapData.height / 2);
				
				colorSampleRect.fill = new SolidColor();
				
				flushTimer.addEventListener(TimerEvent.TIMER, tick);
				flushTimer.start();
				
				if(opsStream == null)
					openOpsStream();
			}
			
			private function sourceAlpha(alpha:Number):void 
			{ 
				sourceBitmap.alpha = alpha;
			}
			
			private function openOpsStream(append:Boolean=false):void
			{
				if(opsStream != null)
					opsStream.close();
				
				opsFile = new File(File.applicationDirectory.nativePath + File.separator + "temp.ops");
				opsStream = new FileStream();
				opsStream.objectEncoding = ObjectEncoding.AMF3;
				
				if(append)
					opsStream.open(opsFile, FileMode.APPEND);
				else
					opsStream.open(opsFile, FileMode.WRITE);
			}
			
			private function saveDrawing(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				if(opsStream != null)
				{
					opsStream.close();
					opsFile.copyTo(
						new File(File.applicationDirectory.nativePath + File.separator + 
							fileName + ".ops"),
						true
					);
					opsStream.open(opsFile, FileMode.APPEND);
				}
			}
			
			private function defaultFrameRect():void
			{
				var centerX:Number = renderGroup.width / 2;
				var centerY:Number = renderGroup.height / 2;
				var xOffset:Number = centerX - 320;
				var yOffset:Number = centerY - 240;
				
				frameWindowRect.x = xOffset;
				frameWindowRect.y = yOffset;
				frameWindowRect.width = 640;
				frameWindowRect.height = 480;
			}
			
			private function _frameWindow(on:Number):void {
				
				if(on == 1)
				{
					if(sourceBitmap.source)
					{
						frameWindowRect.x = sourceBitmap.x;
						frameWindowRect.y = sourceBitmap.y;
						frameWindowRect.width = sourceBitmap.width;
						frameWindowRect.height = sourceBitmap.height;
					}
					else
						defaultFrameRect();
					
					frameWindow.graphics.lineStyle(1, 0x000000, 1.0, false, LineScaleMode.NONE);
					frameWindow.graphics.drawRect(frameWindowRect.x, frameWindowRect.y, frameWindowRect.width, frameWindowRect.height);	
				}
				else
					frameWindow.graphics.clear();
			}
			
			private function export(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				if(frameWindowRect.width == 0)
					defaultFrameRect();
				
				// 41' x 27' = 12300 x 8100
				var targetWidth:int = 12300;
				var targetHeight:int = 8100;
				var exportBitmap:Bitmap = new Bitmap(new BitmapData(targetWidth, targetHeight));
				
				var scaleX:Number = targetWidth  / frameWindowRect.width;
				var scaleY:Number = targetHeight / frameWindowRect.height;
				
				if(opsStream != null)
					opsStream.close();
				else
				{
					opsFile = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".ops");
					opsStream = new FileStream();
					opsStream.objectEncoding = ObjectEncoding.AMF3;
				}
				
				opsStream.open(opsFile, FileMode.READ);

				var tempBrushes:Array = new Array();
				var tempOps:Array = new Array();
				
				while(opsStream.bytesAvailable > 0)
					tempOps.push(opsStream.readObject());
				
				opsStream.close();
				
				var divisions:int = 10;
				var interval:int = int(tempOps.length / divisions);
				var t:Timer = new Timer(0.01, divisions + 1);
				var i:int = 0;
				var offset:int = interval;
				
				t.addEventListener(TimerEvent.TIMER, function (event:TimerEvent):void {
					
					for(; i < offset; ++i)
					{
						var op:Object = tempOps[i];
						
						if(op != null) 
						{
							if(tempBrushes[op.t] == null)
							{
								var BrushClass:Class = getDefinitionByName("brush.Brush" + op.t) as Class;
								tempBrushes[op.t] = new BrushClass();
								tempBrushes[op.t].sourceBitmap = sourceBitmap;
							}
					
							tempBrushes[op.t].drawOp(canvasContainer.graphics, op)
						}
					}
					
					var m:Matrix = new Matrix();
					
					var centerX:Number = renderGroup.width / 2;
					var centerY:Number = renderGroup.height / 2;
					var xOffset:Number = centerX - (frameWindowRect.width  / 2);
					var yOffset:Number = centerY - (frameWindowRect.height / 2);
					m.translate(-xOffset, -yOffset);
					
					m.scale(scaleX, scaleY);
					exportBitmap.bitmapData.draw(canvasContainer, m);
					canvasContainer.graphics.clear();
					
					// TODO: LineScaleMode.NONE option
					
					offset += interval;
					if(offset > tempOps.length)
						offset = tempOps.length;
					
				});
				
				t.addEventListener(TimerEvent.TIMER_COMPLETE, function(event:TimerEvent):void {
					
					trace("encoding byte array...");
					var png:PNGEncoder = new PNGEncoder();
					var byteArray:ByteArray = png.encode(exportBitmap.bitmapData);
					
					trace("exporting file...");
					var exportFile:File = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".png")
					var fs:FileStream = new FileStream();
					fs.openAsync(exportFile,FileMode.WRITE);
					fs.writeBytes(byteArray);
					fs.close();
					trace("file exported");
				});
				
				t.start();
			}
			
			// ........................................................................................
			
			private function loadBrush(brushNum:Number):void
			{
				if(brushNum == 0)
				{
					status = "! specify a brush #";
					statusTimer.start();
					return;
				}
				
				var BrushClass:Class = getDefinitionByName("brush.Brush" + brushNum) as Class;
				brushes[brushNum] = new BrushClass();
				brushes[brushNum].sourceBitmap = sourceBitmap;
				brushes[brushNum].renderGroupOffsetX = renderGroup.x;
				brushes[brushNum].renderGroupOffsetY = renderGroup.y;
			}
			
			private function clearBrush(brushNum:Number):void
			{ 
				delete(brushes[brushNum]);
			}
			
			private function clearAllBrushes():void
			{ 
				brushes = new Array();
			}
			
			private function lineWidthBrush(brushNum:Number, value:Number):void
			{ 
				brushes[brushNum].lineWidth = value;
			}
			
			private function alphaBrush(brushNum:Number, value:Number):void 
			{ 
				brushes[brushNum].alpha = value; 
			}
			
			private function radiusBrush(brushNum:Number, value:Number):void
			{
				brushes[brushNum].radius = value;
			}
			
			private function iterationsBrush(brushNum:Number, value:Number):void 
			{ 
				brushes[brushNum].iterations = value;
			}
			
			// ........................................................................................
			
			private function tick(event:TimerEvent):void
			{
				flushToBitmap();
			}
			
			private function flushToBitmap():void
			{
				if(flushBitmap.source != null)
				{
					flushBitmap.source.bitmapData.draw(canvasContainer);	
					canvasContainer.graphics.clear();
				}
			}
			
			private function clear():void
			{
				canvasContainer.graphics.beginFill(0xffffff, 1);
				canvasContainer.graphics.drawRect(0, 0, canvasContainer.width, canvasContainer.height);
				canvasContainer.graphics.endFill();
				if(flushBitmap.source != null)
					flushBitmap.source.bitmapData.draw(canvasContainer);
				canvasContainer.graphics.clear();
				
				openOpsStream();
			}
			
			// ........................................................................................
			
			private function loadBrushSettings(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".brs");
				var fs:FileStream = new FileStream();
				
				fs.objectEncoding = ObjectEncoding.AMF3;
				fs.open(file, FileMode.READ);
				
				var obj:Object = fs.readObject();
				
				var BrushClass:Class = getDefinitionByName("brush.Brush" + obj.brushNum) as Class;
				var br:Brush = new BrushClass();
				br.sourceBitmap = sourceBitmap;
				
				for(var prop:* in obj)
					br[prop] = obj[prop];
				
				brushes[br.brushNum] = br;
				
				fs.close();
			}
			
			private function saveBrushSettings(brushNum:Number, fileName:String):void
			{
				if(brushNum == 0)
				{
					status = "! specify brush number";
					statusTimer.start();
					return;
				}
				
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".brs");
				var fs:FileStream = new FileStream();
				
				fs.objectEncoding = ObjectEncoding.AMF3;
				fs.open(file, FileMode.WRITE);
				
				fs.writeObject(brushes[brushNum] as Brush);
				
				fs.close();
			}
			
			private function automateBrush(offsetX:Number, offsetY:Number):void
			{
				if(offsetX <= 0 || offsetY <= 0)
				{
					status = "! specify a non-zero offset";
					statusTimer.start();
					return;
				}
				
				if(opsStream == null)
					openOpsStream();
				
				for each(var b:Brush in brushes)
					b.mouseDown(sourceBitmap.x, sourceBitmap.y);
				
				var t:Timer = new Timer(0.25, int(sourceBitmap.height / offsetY));
				var i:int = 0;
				var j:int = 0;
				
				t.addEventListener(TimerEvent.TIMER, function (event:TimerEvent):void {
					
					for(; i < sourceBitmap.width; i += offsetX)
					{
						for each(var br:Brush in brushes)
						{
							opsStream.writeObject(
								br.draw(canvasContainer.graphics,
									sourceBitmap.source.bitmapData.getPixel(i, j),
									sourceBitmap.x + i,
									sourceBitmap.y + j,
									null
								)
							);
						}
					}
					
					i = 0;
					j += offsetY;
					
					flushToBitmap();
				});
				
				t.start();
			}
			
			private function loadDrawingOverwrite(fileName:String):void
			{	
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				if(flushBitmap.source == null)
					flushBitmap.source = new Bitmap(new BitmapData(renderGroup.width, renderGroup.height, false, 0xffffff));
				
				if(opsStream != null)
					opsStream.close();
				else
					opsStream = new FileStream();
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".ops");
				opsStream.open(file, FileMode.READ);
				
				var tempBrushes:Array = new Array();
				var tempOps:Array = new Array();
				
				while(opsStream.bytesAvailable > 0)
					tempOps.push(opsStream.readObject());
				
				opsStream.close();
				file.copyTo(
					new File(File.applicationDirectory.nativePath + File.separator + "temp.ops"),
					true
				);
				
				openOpsStream(true);
				
				var divisions:int = 10;
				var interval:int = int(tempOps.length / divisions);
				var t:Timer = new Timer(0.01, divisions + 1);
				var i:int = 0;
				var offset:int = interval;
				
				t.addEventListener(TimerEvent.TIMER, function (event:TimerEvent):void {
					
					for(; i < offset; ++i)
					{
						var op:Object = tempOps[i];
						
						if(op != null)
						{
							if(tempBrushes[op.t] == null)
							{
								var BrushClass:Class = getDefinitionByName("brush.Brush" + op.t) as Class;
								tempBrushes[op.t] = new BrushClass();
								tempBrushes[op.t].sourceBitmap = sourceBitmap;
							}
							
							tempBrushes[op.t].drawOp(canvasContainer.graphics, op);
						}
					}
					
					flushToBitmap();
					
					offset += interval;
					if(offset > tempOps.length)
						offset = tempOps.length;
				});
				
				t.start();
			}
			
			private function draw(event:MouseEvent):void
			{
				for each(var br:Brush in brushes)
				{
					opsStream.writeObject(
						br.draw(canvasContainer.graphics,
								sampleColor,
								event.stageX - renderGroup.x,
								event.stageY - renderGroup.y,
								colorList)
					);
				}
			}
			
			// ........................................................................................
			
			protected function renderGroup_mouseDownHandler(event:MouseEvent):void
			{
				renderGroup.setFocus();
					
				if(sourceBitmap.source)
				{
					flushTimer.start();
					
					for each(var b:Brush in brushes)
						b.mouseDown(event.stageX - renderGroup.x, event.stageY - renderGroup.y);
					
					draw(event);
				}
			}
			
			protected function renderGroup_mouseUpHandler(event:MouseEvent):void
			{
				if(sourceBitmap.source)
				{
					for each(var b:Brush in brushes)
						b.mouseUp(event.stageX - renderGroup.x, event.stageY - renderGroup.y);
					
					flushTimer.stop();
					flushToBitmap();
					
					openOpsStream(true);
				}
			}
			
			protected function renderGroup_mouseMoveHandler(event:MouseEvent):void
			{
				if(sourceBitmap.source)
				{
					if(outsideSourceFlag)
					{
						stagePoint.x = event.stageX;
						stagePoint.y = event.stageY;
						sourceLocal = sourceBitmap.globalToLocal(stagePoint);
						
						// clamp
						if(sourceLocal.x < 0)
							sourceLocal.x = 0;
						else if(sourceLocal.x > sourceBitmap.source.bitmapData.width)
							sourceLocal.x = sourceBitmap.source.bitmapData.width - 1;
						if(sourceLocal.y < 0)
							sourceLocal.y = 0;
						else if(sourceLocal.y > sourceBitmap.source.bitmapData.height)
							sourceLocal.y = sourceBitmap.source.bitmapData.height - 1;
						
						sampleColor = sourceBitmap.source.bitmapData.getPixel(sourceLocal.x, sourceLocal.y);
						SolidColor(colorSampleRect.fill).color = sampleColor;
					}
					
					if(event.buttonDown)
						draw(event);
				}
			}
			
			protected function renderGroup_mouseOverHandler(event:MouseEvent):void
			{
				colorSampleRect.visible = true;
			}
			
			protected function renderGroup_mouseOutHandler(event:MouseEvent):void
			{
				colorSampleRect.visible = false;
			}
			
			// ........................................................................................
			
			protected function sourceBitmap_mouseOverHandler(event:MouseEvent):void
			{
				outsideSourceFlag = false;
				mousePosLabel.visible = true;
			}
			
			protected function sourceBitmap_mouseOutHandler(event:MouseEvent):void
			{
				outsideSourceFlag = true;
				mousePosLabel.visible = false;
			}
			
			protected function sourceBitmap_mouseMoveHandler(event:MouseEvent):void
			{
				mousePosLabel.text = StringUtil.substitute("{x:{0}, y:{1}}", event.localX, event.localY);
				
				if(sourceBitmap.source)
				{
					sampleColor = sourceBitmap.source.bitmapData.getPixel(event.localX, event.localY);
					SolidColor(colorSampleRect.fill).color = sampleColor;
				
					if(event.controlKey && event.shiftKey)
					{
						var r:Rect = new Rect();
						r.width = 20;
						r.height = 20;
						r.fill = new SolidColor(sampleColor);
						colorList.addItem(r);
					}
					
					if(event.buttonDown)
						draw(event);
				}
				
				event.stopImmediatePropagation();
			}
			
			protected function list_changeHandler(event:IndexChangeEvent):void
			{
				var currentIndx:int = event.currentTarget.selectedIndex;
				var currentDataItem:Object = event.currentTarget.selectedItem;
			}
			
			protected function list_keyDownHandler(event:KeyboardEvent):void
			{
				//TODO: shift click delete selection
				if(event.charCode == 8 && list.selectedIndex != -1) // delete key
				{
					var lastIndex:int = list.selectedIndex;
					colorList.removeItemAt(lastIndex);
					
					if(lastIndex < colorList.length - 1)
						list.selectedIndex = lastIndex;
					else if(colorList.length > 0)
						list.selectedIndex = colorList.length - 1;
				}
			}
			
		]]>
	</fx:Script>
	
	<s:VGroup id="vgroup" 
			  width="100%" height="100%"
			  paddingBottom="40" paddingLeft="40" paddingRight="40" paddingTop="40"
			  >
		
		<s:TextInput id="input" 
					 width="100%" 
					 focusEnabled="false"
					 fontFamily="Monaco"
					 fontSize="11"
					 keyDown="inputKeyDown(event)"
					 />
	
		<s:SkinnableContainer
				id="renderGroup"
				width="100%" height="100%"
				backgroundColor="{canvasBackgroundColor}"
				mouseMove="renderGroup_mouseMoveHandler(event)"
				mouseOut="renderGroup_mouseOutHandler(event)"
				mouseOver="renderGroup_mouseOverHandler(event)"
				mouseDown="renderGroup_mouseDownHandler(event)"
				mouseUp="renderGroup_mouseUpHandler(event)"
				>
			
			<s:BitmapImage id="flushBitmap" width="100%" height="100%"/>
			
			<s:Image id="sourceBitmap" 
					 mouseMove="sourceBitmap_mouseMoveHandler(event)"
					 mouseOut="sourceBitmap_mouseOutHandler(event)"
					 mouseOver="sourceBitmap_mouseOverHandler(event)"
					 />
			
			<s:SpriteVisualElement id="canvasContainer"
								   width="100%" height="100%"/>
			<s:SpriteVisualElement id="frameWindow"
								   width="100%" height="100%"/>
		
		</s:SkinnableContainer>
		
		<s:List id="list"
				tabFocusEnabled="false"
				itemRenderer="spark.skins.spark.DefaultComplexItemRenderer"
				horizontalCenter="0"
				verticalCenter="0"
				dataProvider="{ colorList }"
				change="list_changeHandler(event)"
				keyDown="list_keyDownHandler(event)"
				allowMultipleSelection="true"
				width="100%"
				height="40">
			<s:layout>
				<s:TileLayout id="tile"
							  requestedRowCount="1"
							  horizontalGap="0"
							  verticalGap="0"
							  />
			</s:layout>
		</s:List>
		
		<s:HGroup width="100%" verticalAlign="baseline">
			<s:HGroup width="100%" horizontalAlign="left">
				<s:Rect id="colorSampleRect" width="10" height="10"/>
			</s:HGroup>	
			
			<s:HGroup width="100%" gap="20" horizontalAlign="right">	
				<s:Label id="mousePosLabel"
						 paddingTop="10" 
						 color="0xacacac"
						 fontFamily="Monaco" fontSize="9"
						 width="87"
						 />
				
				<s:Label id="fpsLabel" 
					paddingTop="10" 
					color="0xacacac"
					fontFamily="Monaco" fontSize="9"
					/>			
			</s:HGroup>
		</s:HGroup>

	</s:VGroup>
	
</s:WindowedApplication>
