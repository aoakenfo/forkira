<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   initialize="windowedApplication_initializeHandler(event)"
					   creationComplete="windowedapplication_creationCompleteHandler(event)"
					   keyDown="windowedapplication_keyDownHandler(event)"
					   applicationComplete="windowedapplication1_applicationCompleteHandler(event)"
					   usePreloader="false"
					   backgroundAlpha="0"
					   backgroundColor="#696969"
					   showStatusBar="true"
					   frameRate="60"
					   >
	
	<fx:Script>
		<![CDATA[
			import brush.Brush;
			import brush.Brush1;
			import brush.Brush10;
			import brush.Brush11;
			import brush.Brush2;
			import brush.Brush3;
			import brush.Brush4;
			import brush.Brush5;
			import brush.Brush6;
			import brush.Brush7;
			import brush.Brush8;
			import brush.Brush9;
			
			import flash.utils.getDefinitionByName;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ArrayList;
			import mx.controls.Alert;
			import mx.events.FlexEvent;
			import mx.events.IndexChangedEvent;
			import mx.graphics.SolidColor;
			import mx.graphics.codec.PNGEncoder;
			import mx.managers.PopUpManager;
			import mx.utils.StringUtil;
			
			import ru.inspirit.encoders.png.PNGEncoder;
			import ru.inspirit.encoders.png.PNGEncoderInfo;
			
			import spark.components.Application;
			import spark.events.IndexChangeEvent;
			import spark.filters.DropShadowFilter;
			import spark.skins.spark.ImageSkin;
			
			// ........................................................................................
			
			// include refs for getDefinitionByName
			private var b1:Brush1;
			private var b2:Brush2;
			private var b3:Brush3;
			private var b4:Brush4;
			private var b5:Brush5;
			private var b6:Brush6;
			private var b7:Brush7;
			private var b8:Brush8;
			private var b9:Brush9;
			private var b10:Brush10;
			private var b11:Brush11;

			private var frameCount:uint = 0;
			private var curMillisecondCount:uint = 0;
			private var prevMillisecondCount:uint = getTimer();
			private var fps:Number = 0.0;
			private var delta:uint;
			
			[Bindable] private var canvasBackgroundColor:uint = 0xffffff;
			
			private var outsideSourceFlag:Boolean = false;
			private var sourceLocal:Point = new Point();
			private var stagePoint:Point = new Point();
			private var sampleColor:uint = 0;
			
			private var flushTimer:Timer = new Timer(1000);
			private var statusTimer:Timer = new Timer(2000, 1);
			
			private var keyBinds:Array = new Array();
			
			private var brushes:Array = new Array();
			
			private var lastCommandInput:Array = new Array();
			private var lastInputIndex:int = -1;
			
			private var opsStream:FileStream = null;
			private var opsFile:File = null;
			
			private var frameWindowRect:Rect = null;
			private var aspectRatioInchesX:Number = 41; // 41' * 300 dpi = 12300 px
			private var aspectRatioInchesY:Number = 27; // 27' * 300 dpi = 8100 px
			
			[Bindable] private var colorList:ArrayList = new ArrayList();
			
			// ........................................................................................
			
			protected function windowedApplication_initializeHandler(event:FlexEvent):void
			{
				this.nativeWindow.maximize();
				
				ConsoleCommand.addCommand("exit", _exit, false);
				ConsoleCommand.addCommand("load-drawing", loadDrawing);
				ConsoleCommand.addCommand("save-drawing", saveDrawing);
				ConsoleCommand.addCommand("load-image", loadImagePath);
				ConsoleCommand.addCommand("frame-rate", _frameRate);			
				ConsoleCommand.addCommand("image-alpha", sourceAlpha);
				ConsoleCommand.addCommand("bind-key", bindKey);
				ConsoleCommand.addCommand("save-key-binds", saveKeyBinds);
				ConsoleCommand.addCommand("load-key-binds", loadKeyBinds);
				ConsoleCommand.addCommand("clear", clear);
				ConsoleCommand.addCommand("load-brush", loadBrush);
				ConsoleCommand.addCommand("line-width", lineWidthBrush);
				ConsoleCommand.addCommand("alpha", alphaBrush);
				ConsoleCommand.addCommand("radius", radiusBrush);
				ConsoleCommand.addCommand("iterations", iterationsBrush);
				ConsoleCommand.addCommand("automate", automateBrush);
				ConsoleCommand.addCommand("save-brush-settings", saveBrushSettings);
				ConsoleCommand.addCommand("load-brush-settings", loadBrushSettings);
				ConsoleCommand.addCommand("export", export);
				ConsoleCommand.addCommand("frame-window", _frameWindow);
				ConsoleCommand.addCommand("clear-all-brushes", clearAllBrushes, false);
				ConsoleCommand.addCommand("clear-brush", clearBrush);
				ConsoleCommand.addCommand("clear-palette", function():void { colorList = new ArrayList(); }, false);
				ConsoleCommand.addCommand("randomize-offset", randomizeOffset);
				ConsoleCommand.addCommand("plus-minus-offset-range", plusMinusOffsetRange);
				ConsoleCommand.addCommand("line-style-enabled", lineStyleEnabled);
				ConsoleCommand.addCommand("set-aspect-ratio-inches", function(inchesX:Number, inchesY:Number):void {
					aspectRatioInchesX = inchesX;
					aspectRatioInchesY = inchesY;
				});
				ConsoleCommand.addCommand("rotate-frame-window", function():void {
					
					var aspectX:Number = aspectRatioInchesX;
					aspectRatioInchesX = aspectRatioInchesY;
					aspectRatioInchesY = aspectX;
					
					if(frameWindowRect != null)
						createFrameRect(frameWindowRect.height);
					else
						createFrameRect(421.4634146341463);
					
				}, false);
				ConsoleCommand.addCommand("total-bristles", function (brushNum:Number, numBristles:Number):void {
					brushes[brushNum].totalBristles(numBristles);
				});
				ConsoleCommand.addCommand("line-thickness", function (brushNum:Number, value:Number):void {
					brushes[brushNum].lineThickness = value;
				});
				ConsoleCommand.addCommand("line-thickness-multiplier", function (brushNum:Number, value:Number):void {
					brushes[brushNum].lineThicknessMultiplier = value;
				});
				ConsoleCommand.addCommand("offset-x", function (brushNum:Number, value:Number):void {
					brushes[brushNum].offsetX = value;
				});
				ConsoleCommand.addCommand("offset-y", function (brushNum:Number, value:Number):void {
					brushes[brushNum].offsetY = value;
				});
				ConsoleCommand.addCommand("rounded-corner", function (brushNum:Number, value:Number):void {
					brushes[brushNum].roundedCorner = value;
				});
				ConsoleCommand.addCommand("help", help, false);
				ConsoleCommand.addCommand("help-brush", helpBrush);
			}
			
			private function help():void
			{
				var dialog:HelpDialog = new HelpDialog();
				PopUpManager.addPopUp(dialog, this, true);
				
				dialog.commandList = new ArrayCollection(new Array(

					"load-image <file name>" +
						"\n    Open a JPG or PNG image to draw." +
						"\n    The file must be located in the application directory. Specify the file extension." +
						"\n    Example usage: load-image ~/Desktop/pic.jpg",
						
					"image-alpha <value>" +
						"\n    Set the transparency of the source image. Value range is 0 to 1." +
						"\n    Example-usage: image-alpha 0.5",
						
					"save-drawing <file name>" +
						"\n    Save the current drawing to file. Does not save any brush settings." +
						"\n    Example usage: save-drawing myDrawing",
						
					"load-drawing <file name>" +
						"\n    Load a previous drawing from file. Does not recreate any of the brushes used in drawing." +
						"\n    Example usage: load-drawing myDrawing",
					
					"clear" +
						"\n    Clears the current drawing without saving.",
					
					"frame-rate" +
						"\n    Set the target frame rate. The default is 60 frames per second (fps)." +
						"\n    Example usage: frame-rate 60",
					
					"load-brush <brush number>" +
						"\n    Load a brush. Brush numbers range from 1-10." +
						"\n    Example usage: load-brush 4",
					
					"load-brush-settings <file name>" +
						"\n    Load brush settings from a file." +
						"\n    Example usage: load-brush-settings myCustomBrushSettings",
						
					"save-brush-settings <file name>" +
						"\n    Save brush settings to a file." +
						"\n    Example usage: save-brush-settings myCustomBrushSettings",
					
					"clear-all-brushes" +
						"\n    Remove all brushes and settings.",
					
					"clear-brush <brush number>" +
						"\n    Clear a specific brush." +
						"\n    Example usage: clear-brush 4",
					
					"clear-palette" +
						"\n    Remove all colors from the palette.",
					
					"automate <x-offset y-offset>" +
						"\n    Simulate a mouse click every x, y offset." +
						"\n    Example usage: automate 10 10",
					
					"export <file name>" +
						"\n    Export a poster sized PNG." +
						"\n    Example usage: export myPoster",
					
					"frame-window" +
						"\n    Show or hide the poster frame window." +
						"\n    ⌘= to increase size by 10 pixels. ⌘⇧= to increase size by 1 pixel." +
						"\n    ⌘- to decrase size by 10 pixels. ⌘⇧- to decrease size by 1 pixel." +
						"\n    ⌘⇠⇡⇢⇣ to move positiion by 10 pixels. ⌘⇧⇠⇡⇢⇣ to move position by 1 pixel." +
						"\n    Example usage: frame-window 1",
					
					"rotate-frame-window" +
						"\n    Rotate the frame window between portrait and landscape.",
					
					"set-aspect-ratio-inches" +
						"\n    Determines the size of the image to export. Default is 41' x 27'." +
						"\n    Example usage: set-aspect-ratio-inches 47 21",
					
					"bind-key" +
						"\n    Bind a command to a key, allowing you to change brush properties in realtime." +
						'\n    Example usage: bind-key r "radius 1 50"' +
						'\n    Example usage: bind-key r "radius 1 50; line-width 1 1"',
					
					"save-key-binds" +
						"\n    Saves the current set of key binds to file." +
						"\n    Example usage: save-key-binds myKeyBinds",
					
					"load-key-binds" +
						"\n    Load a previous set of key binds from file." +
						"\n    Example usage: load-key-binds myKeyBinds",
					
					"help-brush <brush number>" +
						"\n    Show commands that can be used to adjust the settings of a specific brush" + 
						"\n    Example usage: help-brush 4",
					
					"exit" +
						"\n    Quit the program without saving"
				));
				
				PopUpManager.centerPopUp(dialog);
			}
			
			private function helpBrush(brushNum:Number):void
			{
				if(brushes[brushNum] == null)
					return;
				
				var dialog:HelpDialog = new HelpDialog();
				PopUpManager.addPopUp(dialog, this, true);
				
				dialog.commandList = new ArrayCollection(brushes[brushNum].help());
				
				PopUpManager.centerPopUp(dialog);
			}
			
			protected function windowedapplication_creationCompleteHandler(event:FlexEvent):void
			{
				var dropShadow:DropShadowFilter = new spark.filters.DropShadowFilter();
				dropShadow.color = 0x000000;
				dropShadow.alpha = 0.4;
				dropShadow.blurX = 5;
				dropShadow.blurY = 5;
				dropShadow.distance = 5;
				input.filters = [dropShadow];
				renderGroup.filters = [dropShadow];
				list.filters = [dropShadow];
				
				input.setFocus();
					
				this.addEventListener(Event.ENTER_FRAME, windowedApplication_enterFrameHandler);
				statusTimer.addEventListener(TimerEvent.TIMER_COMPLETE, function (event:TimerEvent):void {
					status = "";
				});
				
				//vgroup.swapElements(input, renderGroup);
			}
			
			private function windowedApplication_enterFrameHandler(event:Event):void
			{
				++frameCount;
				
				curMillisecondCount = getTimer();
				delta = curMillisecondCount - prevMillisecondCount;
				if (delta > 1000)
				{
					fps = frameCount / delta * 1000;
					fpsLabel.text = fps.toFixed(1) + " fps";
					prevMillisecondCount = curMillisecondCount;
					frameCount = 0;		
				}
			}
			
			private function _exit():void
			{ 
				if(opsStream != null)
				{
					opsStream.close();
					opsStream = null;
				}
				
				exit(); 
			}
			
			private function _frameRate(frameRate:Number):void 
			{ 
				if(frameRate == 0)
				{
					status = "! frame-rate cannot be 0";
					statusTimer.start();
					return;
				}
				stage.frameRate = frameRate; 
			}
			
			protected function windowedapplication_keyDownHandler(event:KeyboardEvent):void
			{
				if(event.commandKey)
				{
					switch(event.keyCode)
					{
						case Keyboard.L:
							
							input.setFocus();
							
							break;
						
						case Keyboard.EQUAL:
							
							adjustFrameWindowSize(event.shiftKey ? 1 : 10);
					
							break;
						
						case Keyboard.MINUS:
							
							adjustFrameWindowSize(event.shiftKey ? -1: -10);
							
							break;
						
						case Keyboard.LEFT:
							
							adjustFramePosition(event.shiftKey ? -1 : -10, 0);
							
							break;
						
						case Keyboard.RIGHT:
							
							adjustFramePosition(event.shiftKey ? 1 : 10, 0);
							
							break;
						
						case Keyboard.UP:
							
							adjustFramePosition(0, event.shiftKey ? -1 : -10);
							
							break;
						
						case Keyboard.DOWN:
							
							adjustFramePosition(0, event.shiftKey ? 1 : 10);
							
							break;
					}
				}
				else
				{
					if(keyBinds[event.charCode])
						ConsoleCommand.process(keyBinds[event.charCode]);
				}
			}
			
			// ........................................................................................
			
			private function loadKeyBinds(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName);
				if(file.exists)
				{
					var fs:FileStream = new FileStream();
					
					fs.open(file, FileMode.READ);
					
					var fullBindListing:String = fs.readUTFBytes(fs.bytesAvailable);
					var tokens:Array = fullBindListing.split("\n");
					
					// bind-key 
					for each(var input:String in tokens)
					{
						// assumed input; will blow up otherwise
						var key:String = input.substr("bind-key ".length, 1);
						keyBinds[key.charCodeAt()] = input.substring("bind-key x \"".length, input.length-1); // remove double quotes
					}
					
					fs.close();
				}
			}
			
			private function saveKeyBinds(fileName:String):void
			{	
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName);
				var fs:FileStream = new FileStream();
				
				fs.open(file, FileMode.WRITE);
				
				for (var key:String in keyBinds)
					fs.writeUTFBytes(StringUtil.substitute("bind-key {0} \"{1}\"\n", String.fromCharCode(key), keyBinds[key]));
				
				fs.close();
			}
			
			private function bindKey(key:String, input:String):void
			{
				keyBinds[key.charCodeAt()] = input;
			}
			
			protected function inputKeyDown(event:KeyboardEvent):void
			{	
				switch(event.keyCode)
				{
					case Keyboard.ESCAPE:
						
						renderGroup.setFocus();
						
						break;
					
					case Keyboard.TAB:
						
						if(input.text.length == 0)
							renderGroup.setFocus();
						else
						{
							var partial:String = ConsoleCommand.autoComplete(input.text);
							if(partial != null)
								input.appendText(partial);
						}
						
						break;
					
					case Keyboard.ENTER:
						lastCommandInput.push(input.text);
						++lastInputIndex;
						try
						{
							ConsoleCommand.process(input.text);
						}
						catch(e:Error)
						{
							status = "! incorrect params";
							statusTimer.start();	
						}
						input.text = "";
						
						break;
					
					case Keyboard.UP:
						
						input.text = "";
						input.appendText(lastCommandInput[lastInputIndex]);

						if(lastInputIndex > 0)
							--lastInputIndex;
						
						break;
					
					case Keyboard.DOWN:
						if(lastInputIndex < lastCommandInput.length - 1)
							++lastInputIndex;
						
						input.text = "";
						input.appendText(lastCommandInput[lastInputIndex]);

						break;
				}
				
				event.stopImmediatePropagation();
			}
			
			// ........................................................................................
			
		 	private function loadImage(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var dirListing:Array = File.applicationDirectory.getDirectoryListing();
				
				for each(var file:File in dirListing)
				{       
					if(file.name == fileName)
					{       
						var loader:Loader = new Loader();
						loader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadCompleteHandler);
						loader.load(new URLRequest(file.url)); 
					}
				}
			}
			
			private function loadImagePath(filePath:String):void
			{
				if(filePath.substr(0, 1) == "~")
					filePath= File.userDirectory.nativePath + filePath.substr(1);
						
				var file:File = new File(filePath);
				if(file.exists)
				{
					var loader:Loader = new Loader();
					loader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadCompleteHandler);
					loader.load(new URLRequest(file.url)); 
				}
			}
			
			private function imageLoadCompleteHandler(event:Event):void
			{	
				var bitmap:Bitmap = event.currentTarget.content as Bitmap;
				sourceBitmap.source = bitmap;
				
				if(flushBitmap.source == null)
					flushBitmap.source = new Bitmap(new BitmapData(renderGroup.width, renderGroup.height, false, 0xffffff));
				
				var centerX:Number = renderGroup.width / 2;
				var centerY:Number = renderGroup.height / 2;
				
				sourceBitmap.x = centerX - (sourceBitmap.source.bitmapData.width  / 2);
				sourceBitmap.y = centerY - (sourceBitmap.source.bitmapData.height / 2);
				
				colorSampleRect.fill = new SolidColor();
				
				flushTimer.addEventListener(TimerEvent.TIMER, tick);
				flushTimer.start();
				
				if(opsStream == null)
					openOpsStream();
			}
			
			private function sourceAlpha(alpha:Number):void 
			{ 
				sourceBitmap.alpha = alpha;
			}
			
			private function openOpsStream(append:Boolean=false):void
			{
				if(opsStream != null)
					opsStream.close();
				
				opsFile = new File(File.applicationDirectory.nativePath + File.separator + "temp.ops");
				opsStream = new FileStream();
				opsStream.objectEncoding = ObjectEncoding.AMF3;
				
				if(append)
					opsStream.open(opsFile, FileMode.APPEND);
				else
					opsStream.open(opsFile, FileMode.WRITE);
			}
			
			private function saveDrawing(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				if(opsStream != null)
				{
					opsStream.close();
					opsFile.copyTo(
						new File(File.applicationDirectory.nativePath + File.separator + 
							fileName + ".ops"),
						true
					);
					opsStream.open(opsFile, FileMode.APPEND);
				}
			}
			
			private function pixelHeightForAspectRatio(aspectInchesX:Number, aspectInchesY:Number, targetPixelWidth:Number):Number
			{
				return  pixelsForInches(aspectInchesY) / pixelsForInches(aspectInchesX) * targetPixelWidth;
			}
			
			private function pixelsForInches(inches:Number, dpi:Number=300):Number
			{
				return inches * dpi;
			}
			
			private function adjustFrameWindowSize(value:Number):void
			{
				var frameWidth:Number = frameWindowRect.width;
				frameWidth += value;
				
				createFrameRect(frameWidth, true);
			}
			
			private function adjustFramePosition(xOffset:Number, yOffset:Number):void
			{
				frameWindowRect.x += xOffset;
				frameWindowRect.y += yOffset;
				
				frameWindow.graphics.clear();
				frameWindow.graphics.lineStyle(1, 0x000000, 1.0, false, LineScaleMode.NONE);
				frameWindow.graphics.drawRect(frameWindowRect.x, frameWindowRect.y, frameWindowRect.width, frameWindowRect.height);	
			}
			
			private function createFrameRect(pixelWidth:Number, useCurrentOffset:Boolean=false):void
			{
				if(frameWindowRect == null)
					frameWindowRect = new Rect();
				
				var frameWidth:Number = pixelWidth;
				var frameHeight:Number = pixelHeightForAspectRatio(aspectRatioInchesX, aspectRatioInchesY, frameWidth);
				
				var centerX:Number;
				var centerY:Number;
				
				if(useCurrentOffset)
				{
					centerX = frameWindowRect.x + (frameWindowRect.width  / 2);
					centerY = frameWindowRect.y + (frameWindowRect.height / 2);
				}
				else
				{
					centerX = renderGroup.width  / 2;
					centerY = renderGroup.height / 2;
				}
				
				var xOffset:Number = centerX - (frameWidth/2);
				var yOffset:Number = centerY - (frameHeight/2);
					
				frameWindowRect.x = xOffset;
				frameWindowRect.y = yOffset;
				
				frameWindowRect.width = frameWidth;
				frameWindowRect.height = frameHeight;
				
				frameWindow.graphics.clear();
				frameWindow.graphics.lineStyle(1, 0x000000, 1.0, false, LineScaleMode.NONE);
				frameWindow.graphics.drawRect(frameWindowRect.x, frameWindowRect.y, frameWindowRect.width, frameWindowRect.height);	
			}
			
			private function _frameWindow(on:Number):void {
				
				if(on == 1)
				{
					if(frameWindowRect == null)
						createFrameRect(640);
				}
				else
					frameWindow.graphics.clear();
			}
			
			private function export(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var dialog:ExportDialog = new ExportDialog();
				PopUpManager.addPopUp(dialog, this, true);
				
				dialog.progressBar.label = "";
				dialog.progressBar.setProgress(0, 100);
				
				PopUpManager.centerPopUp(dialog);
				
				if(frameWindowRect == null)
					createFrameRect(640);

				var targetWidth:Number = pixelsForInches(aspectRatioInchesX);
				var targetHeight:Number = pixelsForInches(aspectRatioInchesY);
				
				var exportBitmap:Bitmap = new Bitmap(new BitmapData(targetWidth, targetHeight), PixelSnapping.ALWAYS, true);
					
				var scaleX:Number = targetWidth  / frameWindowRect.width;
				var scaleY:Number = targetHeight / frameWindowRect.height;
				
				if(opsStream != null)
					opsStream.close();
				else
				{
					var filePath:String = File.applicationDirectory.nativePath + File.separator + fileName + ".ops";
					opsFile = new File(filePath);
					opsStream = new FileStream();
					opsStream.objectEncoding = ObjectEncoding.AMF3;
				}
				
				opsStream.addEventListener(ProgressEvent.PROGRESS, function(e:ProgressEvent):void {
					
					dialog.statusLabel.text = "loading drawing..." + Math.round(e.bytesLoaded / e.bytesTotal * 100) + "%";
					dialog.progressBar.setProgress(Math.round(e.bytesLoaded / e.bytesTotal * 100), 100);
					
				});
				
				opsStream.addEventListener(Event.COMPLETE, function(e:Event):void {
					
					System.gc();
					
					var tempBrushes:Array = new Array();
					var tempOps:Array = new Array();
					
					var origFps:Number = stage.frameRate;
					stage.frameRate = 1000; // timers ultimately limited by frame rate
					
					var rt:Timer = new Timer(0.001);
					var count:uint = 0;
					var totalBytes:uint = opsStream.bytesAvailable;
					
					rt.addEventListener(TimerEvent.TIMER, function (e:TimerEvent):void {
						
						if(opsStream.bytesAvailable > 0)
						{
							dialog.statusLabel.text = "reading vector " + (++count);
							dialog.progressBar.setProgress(Math.round((1-opsStream.bytesAvailable/totalBytes) * 100), 100);
							
							tempOps.push(opsStream.readObject());
						}
						else
						{	
							System.gc();
							rt.stop();
							
							opsStream.close();
							opsStream = null;
							
							var divisions:int = int(tempOps.length * 0.10);
							var interval:int = int(tempOps.length / divisions);
							var t:Timer = new Timer(0.001, divisions + 1);
							var i:int = 0;
							var offset:int = interval;
							
							t.addEventListener(TimerEvent.TIMER, function (event:TimerEvent):void {
								
								dialog.progressBar.setProgress(Math.round((dialog.progressBar.value + (100 / divisions)) * 100) / 100, 100);
								dialog.statusLabel.text = "rendering offscreen canvas..." + dialog.progressBar.value + "%";
								
								for(; i < offset; ++i)
								{
									var ops:Array = tempOps[i];
									
									if(ops != null) 
									{
										for each(var op:Object in ops)
										{
											if(tempBrushes[op.t] == null)
											{
												var BrushClass:Class = getDefinitionByName("brush.Brush" + op.t) as Class;
												tempBrushes[op.t] = new BrushClass();
												tempBrushes[op.t].sourceBitmap = sourceBitmap;
											}
											
											tempBrushes[op.t].drawOp(canvasContainer.graphics, op)
										}
									}
								}
								
								var m:Matrix = new Matrix();
								
								var centerX:Number = frameWindowRect.x + (frameWindowRect.width  / 2);
								var centerY:Number = frameWindowRect.y + (frameWindowRect.height / 2);
								
								var xOffset:Number = centerX - (frameWindowRect.width  / 2);
								var yOffset:Number = centerY - (frameWindowRect.height / 2);
								
								m.translate(-xOffset, -yOffset);
								m.scale(scaleX, scaleY);
								
								exportBitmap.bitmapData.draw(canvasContainer, m);
								canvasContainer.graphics.clear();
								
								offset += interval;
								if(offset > tempOps.length)
									offset = tempOps.length;
								
							});
					
							t.addEventListener(TimerEvent.TIMER_COMPLETE, function(event:TimerEvent):void {
								
								System.gc();
								png.encodeAsync(exportBitmap.bitmapData);
							});
							
							var png:ru.inspirit.encoders.png.PNGEncoder = new ru.inspirit.encoders.png.PNGEncoder();
					
							png.addEventListener(ProgressEvent.PROGRESS, function (e:ProgressEvent):void {
								
									dialog.progressBar.setProgress(e.bytesLoaded/e.bytesTotal * 100, 100);
									dialog.statusLabel.text = 'encoding png...' + Math.round(dialog.progressBar.value*100)/100 + "%";
								}
							);
							
							png.addEventListener(Event.COMPLETE, function (e:Event):void {
									
								var data:ByteArray = ru.inspirit.encoders.png.PNGEncoder.encodedPNGData;
								var exportFile:File = new File(File.desktopDirectory.nativePath + File.separator + fileName + ".png")
								var fs:FileStream = new FileStream();
								
								fs.addEventListener(OutputProgressEvent.OUTPUT_PROGRESS, function (e:OutputProgressEvent):void {
										
									if(e.bytesPending == 0)
									{
										PopUpManager.removePopUp(dialog);
										stage.frameRate = origFps;
										System.gc();
									}
									else
									{
										dialog.progressBar.setProgress((1 - e.bytesPending/e.bytesTotal) * 100, 100);
										dialog.statusLabel.text = 'exporting file...' + Math.round(dialog.progressBar.value*100)/100 + "%";
									}
								});
								
								dialog.progressBar.setProgress(0, 100);
								fs.openAsync(exportFile,FileMode.WRITE);
								fs.writeBytes(data);
								fs.close();
							});
						
							dialog.progressBar.setProgress(0, 100);
							t.start();
						}
					});
					
					rt.start();
				});
				
				opsStream.openAsync(opsFile, FileMode.READ);
			}
			
			// ........................................................................................
			
			private function loadBrush(brushNum:Number):void
			{
				if(brushNum == 0)
				{
					status = "! specify a brush #";
					statusTimer.start();
					return;
				}
				
				var BrushClass:Class = getDefinitionByName("brush.Brush" + brushNum) as Class;
				brushes[brushNum] = new BrushClass();
				brushes[brushNum].sourceBitmap = sourceBitmap;
				brushes[brushNum].renderGroupOffsetX = renderGroup.x;
				brushes[brushNum].renderGroupOffsetY = renderGroup.y;
			}
			
			private function randomizeOffset(brushNum:Number, value:Number):void
			{
				brushes[brushNum].randomizeOffset = value == 1;
			}
			
			private function plusMinusOffsetRange(brushNum:Number, value:Number):void 
			{
				brushes[brushNum].plusMinusOffsetRange = value;
			}
			
			private function lineStyleEnabled(brushNum:Number, value:Number):void
			{
				brushes[brushNum].lineStyleEnabled = value == 1;
			}
			
			private function clearBrush(brushNum:Number):void
			{ 
				delete(brushes[brushNum]);
			}
			
			private function clearAllBrushes():void
			{ 
				brushes = new Array();
			}
			
			private function lineWidthBrush(brushNum:Number, value:Number):void
			{ 
				brushes[brushNum].lineWidth = value;
			}
			
			private function alphaBrush(brushNum:Number, value:Number):void 
			{ 
				brushes[brushNum].alpha = value; 
			}
			
			private function radiusBrush(brushNum:Number, value:Number):void
			{
				brushes[brushNum].radius = value;
			}
			
			private function iterationsBrush(brushNum:Number, value:Number):void 
			{ 
				brushes[brushNum].iterations = value;
			}
			
			// ........................................................................................
			
			private function tick(event:TimerEvent):void
			{
				flushToBitmap();
			}
			
			private function flushToBitmap():void
			{
				if(flushBitmap.source != null)
				{
					flushBitmap.source.bitmapData.draw(canvasContainer);	
					canvasContainer.graphics.clear();
				}
			}
			
			private function clear():void
			{
				canvasContainer.graphics.beginFill(0xffffff, 1);
				canvasContainer.graphics.drawRect(0, 0, canvasContainer.width, canvasContainer.height);
				canvasContainer.graphics.endFill();
				if(flushBitmap.source != null)
					flushBitmap.source.bitmapData.draw(canvasContainer);
				canvasContainer.graphics.clear();
				
				openOpsStream();
			}
			
			// ........................................................................................
			
			private function loadBrushSettings(fileName:String):void
			{
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".brs");
				var fs:FileStream = new FileStream();
				
				fs.objectEncoding = ObjectEncoding.AMF3;
				fs.open(file, FileMode.READ);
				
				var obj:Object = fs.readObject();
				
				var BrushClass:Class = getDefinitionByName("brush.Brush" + obj.brushNum) as Class;
				var br:Brush = new BrushClass();
				br.sourceBitmap = sourceBitmap;
				
				for(var prop:* in obj)
					br[prop] = obj[prop];
				
				brushes[br.brushNum] = br;
				
				fs.close();
			}
			
			private function saveBrushSettings(brushNum:Number, fileName:String):void
			{
				if(brushNum == 0)
				{
					status = "! specify brush number";
					statusTimer.start();
					return;
				}
				
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".brs");
				var fs:FileStream = new FileStream();
				
				fs.objectEncoding = ObjectEncoding.AMF3;
				fs.open(file, FileMode.WRITE);
				
				fs.writeObject(brushes[brushNum] as Brush);
				
				fs.close();
			}
			
			private function automateBrush(offsetX:Number, offsetY:Number):void
			{
				if(offsetX <= 0 || offsetY <= 0)
				{
					status = "! specify a non-zero offset";
					statusTimer.start();
					return;
				}
				
				if(opsStream == null)
					openOpsStream();
				
				for each(var b:Brush in brushes)
					b.mouseDown(sourceBitmap.x, sourceBitmap.y);
				
				var t:Timer = new Timer(0.25, int(sourceBitmap.height / offsetY));
				var i:int = 0;
				var j:int = 0;
				
				t.addEventListener(TimerEvent.TIMER, function (event:TimerEvent):void {
					
					for(; i < sourceBitmap.width; i += offsetX)
					{
						for each(var br:Brush in brushes)
						{
							opsStream.writeObject(
								br.draw(canvasContainer.graphics,
									sourceBitmap.x + i,
									sourceBitmap.y + j,
									null
								)
							);
						}
					}
					
					i = 0;
					j += offsetY;
					
					flushToBitmap();
				});
				
				t.start();
			}
			
			private function loadDrawing(fileName:String):void
			{	
				if(fileName == "")
				{
					status = "! specify a file name";
					statusTimer.start();
					return;
				}
				
				var file:File = new File(File.applicationDirectory.nativePath + File.separator + fileName + ".ops");
				
				if(!file.exists)
					return;
				
				var dialog:ExportDialog = new ExportDialog();
				PopUpManager.addPopUp(dialog, this, true);
				
				dialog.progressBar.label = "";
				dialog.progressBar.setProgress(0, 100);
				
				PopUpManager.centerPopUp(dialog);
				
				if(flushBitmap.source == null)
					flushBitmap.source = new Bitmap(new BitmapData(renderGroup.width, renderGroup.height, false, 0xffffff));
				
				if(opsStream != null)
					opsStream.close();
				else
					opsStream = new FileStream();
				
				opsStream.addEventListener(ProgressEvent.PROGRESS, function (e:ProgressEvent):void {
					
					dialog.statusLabel.text = "loading ops..." + Math.round(e.bytesLoaded / e.bytesTotal * 100) + "%";
					dialog.progressBar.setProgress(Math.round(e.bytesLoaded / e.bytesTotal * 100), 100);
					
				});
				
				opsStream.addEventListener(Event.COMPLETE, function (e:Event):void {
					
					var tempBrushes:Array = new Array();
					var tempOps:Array = new Array();
					
					var origFps:Number = stage.frameRate;
					stage.frameRate = 1000; // timers ultimately limited by frame rate
					
					var rt:Timer = new Timer(0.001);
					var count:uint = 0;
					var totalBytes:uint = opsStream.bytesAvailable;
					
					rt.addEventListener(TimerEvent.TIMER, function (e:TimerEvent):void {
						
						if(opsStream.bytesAvailable > 0)
						{
							dialog.statusLabel.text = "reading object " + (++count);
							dialog.progressBar.setProgress(Math.round((1-opsStream.bytesAvailable/totalBytes) * 100), 100);
							tempOps.push(opsStream.readObject());
						}
						else
						{
							rt.stop();
							stage.frameRate = origFps;
							
							PopUpManager.removePopUp(dialog);
						
							opsStream.close();
							opsStream = null;
							
							file.copyTo(
								new File(File.applicationDirectory.nativePath + File.separator + "temp.ops"),
								true
							);
							
							openOpsStream(true);
							
							var divisions:int = int(tempOps.length * 0.10);
							var interval:int = int(tempOps.length / divisions);
							var t:Timer = new Timer(0.001, divisions + 1);
							var i:int = 0;
							var offset:int = interval;
							
							t.addEventListener(TimerEvent.TIMER, function (event:TimerEvent):void {
								
								for(; i < offset; ++i)
								{
									var ops:Array = tempOps[i];
									
									if(ops != null)
									{
										for each(var op:Object in ops)
										{
											if(tempBrushes[op.t] == null)
											{
												var BrushClass:Class = getDefinitionByName("brush.Brush" + op.t) as Class;
												tempBrushes[op.t] = new BrushClass();
												tempBrushes[op.t].sourceBitmap = sourceBitmap;
											}
											
											tempBrushes[op.t].drawOp(canvasContainer.graphics, op);
										}
									}
								}
								
								flushToBitmap();
								
								offset += interval;
								if(offset > tempOps.length)
									offset = tempOps.length;
							});
						
							t.start();	
						}
						
					});
					
					rt.start();
				});
				
				opsStream.openAsync(file, FileMode.READ);
			}
			
			private function draw(event:MouseEvent):void
			{
				for each(var br:Brush in brushes)
				{
					opsStream.writeObject(
						br.draw(canvasContainer.graphics,
								event.stageX - renderGroup.x,
								event.stageY - renderGroup.y,
								colorList)
					);
				}
			}
			
			// ........................................................................................
			
			protected function renderGroup_mouseDownHandler(event:MouseEvent):void
			{
				renderGroup.setFocus();
					
				if(sourceBitmap.source)
				{
					flushTimer.start();
					
					for each(var b:Brush in brushes)
						b.mouseDown(event.stageX - renderGroup.x, event.stageY - renderGroup.y);
					
					draw(event);
				}
			}
			
			protected function renderGroup_mouseUpHandler(event:MouseEvent):void
			{
				if(sourceBitmap.source)
				{
					for each(var b:Brush in brushes)
						b.mouseUp(event.stageX - renderGroup.x, event.stageY - renderGroup.y);
					
					flushTimer.stop();
					flushToBitmap();
					
					openOpsStream(true);
				}
			}
			
			protected function renderGroup_mouseMoveHandler(event:MouseEvent):void
			{
				if(sourceBitmap.source)
				{
					if(outsideSourceFlag)
					{
						stagePoint.x = event.stageX;
						stagePoint.y = event.stageY;
						sourceLocal = sourceBitmap.globalToLocal(stagePoint);
						
						// clamp
						if(sourceLocal.x < 0)
							sourceLocal.x = 0;
						else if(sourceLocal.x > sourceBitmap.source.bitmapData.width)
							sourceLocal.x = sourceBitmap.source.bitmapData.width - 1;
						if(sourceLocal.y < 0)
							sourceLocal.y = 0;
						else if(sourceLocal.y > sourceBitmap.source.bitmapData.height)
							sourceLocal.y = sourceBitmap.source.bitmapData.height - 1;
						
						sampleColor = sourceBitmap.source.bitmapData.getPixel(sourceLocal.x, sourceLocal.y);
						SolidColor(colorSampleRect.fill).color = sampleColor;
					}
					
					if(event.buttonDown)
						draw(event);
				}
			}
			
			protected function renderGroup_mouseOverHandler(event:MouseEvent):void
			{
				colorSampleRect.visible = true;
			}
			
			protected function renderGroup_mouseOutHandler(event:MouseEvent):void
			{
				colorSampleRect.visible = false;
			}
			
			// ........................................................................................
			
			protected function sourceBitmap_mouseOverHandler(event:MouseEvent):void
			{
				outsideSourceFlag = false;
				mousePosLabel.visible = true;
			}
			
			protected function sourceBitmap_mouseOutHandler(event:MouseEvent):void
			{
				outsideSourceFlag = true;
				mousePosLabel.visible = false;
			}
			
			protected function sourceBitmap_mouseMoveHandler(event:MouseEvent):void
			{
				mousePosLabel.text = StringUtil.substitute("{x:{0}, y:{1}}", event.localX, event.localY);
				
				if(sourceBitmap.source)
				{
					sampleColor = sourceBitmap.source.bitmapData.getPixel(event.localX, event.localY);
					SolidColor(colorSampleRect.fill).color = sampleColor;
				
					if(event.controlKey && event.shiftKey)
					{
						var r:Rect = new Rect();
						r.width = 20;
						r.height = 20;
						r.fill = new SolidColor(sampleColor);
						colorList.addItem(r);
					}
					
					if(event.buttonDown)
						draw(event);
				}
				
				event.stopImmediatePropagation();
			}
			
			protected function list_changeHandler(event:IndexChangeEvent):void
			{
				var currentIndx:int = event.currentTarget.selectedIndex;
				var currentDataItem:Object = event.currentTarget.selectedItem;
			}
			
			protected function list_keyDownHandler(event:KeyboardEvent):void
			{
				//TODO: shift click delete selection
				if(event.charCode == 8 && list.selectedIndex != -1) // delete key
				{
					var lastIndex:int = list.selectedIndex;
					colorList.removeItemAt(lastIndex);
					
					if(lastIndex < colorList.length - 1)
						list.selectedIndex = lastIndex;
					else if(colorList.length > 0)
						list.selectedIndex = colorList.length - 1;
				}
			}
			
			protected function windowedapplication1_applicationCompleteHandler(event:FlexEvent):void
			{
				stage.quality = StageQuality.BEST;
			}
			
		]]>
	</fx:Script>
	
	<s:VGroup id="vgroup" 
			  width="100%" height="100%"
			  paddingBottom="40" paddingLeft="40" paddingRight="40" paddingTop="40"
			  >
		
		<s:TextInput id="input" 
					 width="100%" 
					 focusEnabled="false"
					 fontFamily="Monaco"
					 fontSize="11"
					 keyDown="inputKeyDown(event)"
					 />
	
		<s:SkinnableContainer
				id="renderGroup"
				width="100%" height="100%"
				backgroundColor="{canvasBackgroundColor}"
				mouseMove="renderGroup_mouseMoveHandler(event)"
				mouseOut="renderGroup_mouseOutHandler(event)"
				mouseOver="renderGroup_mouseOverHandler(event)"
				mouseDown="renderGroup_mouseDownHandler(event)"
				mouseUp="renderGroup_mouseUpHandler(event)"
				>
			
			<s:BitmapImage id="flushBitmap" width="100%" height="100%"/>
			
			<s:Group clipAndEnableScrolling="true" width="100%" height="100%">
				<s:Image id="sourceBitmap" 
						 mouseMove="sourceBitmap_mouseMoveHandler(event)"
						 mouseOut="sourceBitmap_mouseOutHandler(event)"
						 mouseOver="sourceBitmap_mouseOverHandler(event)"
						 />
			</s:Group>
			
			<s:SpriteVisualElement id="canvasContainer"
								   width="100%" height="100%"/>
			<s:SpriteVisualElement id="frameWindow"
								   width="100%" height="100%"/>
		
		</s:SkinnableContainer>
		
		<s:List id="list"
				tabFocusEnabled="false"
				itemRenderer="spark.skins.spark.DefaultComplexItemRenderer"
				horizontalCenter="0"
				verticalCenter="0"
				dataProvider="{ colorList }"
				change="list_changeHandler(event)"
				keyDown="list_keyDownHandler(event)"
				allowMultipleSelection="true"
				width="100%"
				height="40">
			<s:layout>
				<s:TileLayout id="tile"
							  requestedRowCount="1"
							  horizontalGap="0"
							  verticalGap="0"
							  />
			</s:layout>
		</s:List>
		
		<s:HGroup width="100%" verticalAlign="baseline">
			<s:HGroup width="100%" horizontalAlign="left">
				<s:Rect id="colorSampleRect" width="10" height="10"/>
			</s:HGroup>	
			
			<s:HGroup width="100%" gap="20" horizontalAlign="right">	
				<s:Label id="mousePosLabel"
						 paddingTop="10" 
						 color="0xacacac"
						 fontFamily="Monaco" fontSize="9"
						 width="87"
						 />
				
				<s:Label id="fpsLabel" 
					paddingTop="10" 
					color="0xacacac"
					fontFamily="Monaco" fontSize="9"
					/>			
			</s:HGroup>
		</s:HGroup>

	</s:VGroup>
	
</s:WindowedApplication>
